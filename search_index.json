[["index.html", "Microbiome data science with R/Bioconductor Welcome to Radboud Summer School, July 2022 1 Overview 1.1 Contents and learning goals 1.2 Schedule and organizers 1.3 Acknowledgments", " Microbiome data science with R/Bioconductor Welcome to Radboud Summer School, July 2022 2022-07-09 1 Overview 1.1 Contents and learning goals This course will focus on microbiome data analysis with R/Bioconductor, a popular open source environment for scientific data analysis. You will get an overview of the reproducible data analysis workflows in microbiome research, with a focus on gut-brain axis studies. After the course you will know how to approach new tasks in the analysis of taxonomic profiling data by taking advantage of available documentation and R tools. The teaching follows the open online documentation created by the course teachers, extending the online book Orchestrating Microbiome Analysis (https://microbiome.github.io/OMA). The openly licensed teaching material will be available online during and after the course, following Finnish national recommendations on open education. The training material walks you through the standard steps of biomedical data analysis covering data access, exploration, analysis, visualization, reproducible reporting, and best practices in open science. We will teach generic data analytical skills that are applicable to common data analysis tasks encountered in modern omics research. The teaching format allows adaptations according to the student’s learning speed. 1.2 Schedule and organizers Format In-person course. For detailed schedule, see the course website. Venue University of Radboud. July 11-15, 2022. Expected background Target audience The course is primarily designed for advanced MSc and PhD students, Postdocs, and biomedical researchers who wish to learn new skills in scientific programming and biomedical data analysis. Academic students and researchers encouraged to apply. Priority will be given for local students. Some earlier experience with R or another programming language is recommended. Preparation Advance preparation is expected. Online support is available. See section 3 for instructions. 1.3 Acknowledgments Citation We thank all developers and contributors who have contributed open resources that supported the development of the training material. Kindly cite the course material as Borman et al. (2022) Contact See https://microbiome.github.io License and source code All material is released under the open CC BY-NC-SA 3.0 License and available online during and after the course, following the recommendations on open teaching materials of the national open science coordination in Finland. The source code of this repository is reproducible and contains the Rmd files with executable code. See README. References "],["code-of-conduct.html", "2 Code of Conduct", " 2 Code of Conduct The Bioconductor community values an open approach to science that promotes the sharing of ideas, code, software and expertise collaboration diversity and inclusivity a kind and welcoming environment community contributions We value your attendance and participation at Bioconductor events and in our community. For the full version, enforcement, and reporting instructions, see the Bioconductor code of conduct. "],["start.html", "3 Getting started 3.1 Checklist (before the course) 3.2 Support and resources 3.3 Installing and loading the required R packages", " 3 Getting started 3.1 Checklist (before the course) 3.1.1 Computer setup and installations Setting up the system on your own computer is required to follow the full course and will be useful for later use if you intent to analyze microbiome data on your computer. The required software: R (version &gt;4.2.0) RStudio; choose “Rstudio Desktop” to download the latest version. Optional but preferred. For further details, check the Rstudio home page. Install and load the required R packages (see Section 3.3) After a successful installation you can start with the case study examples in this training material 3.2 Support and resources We recommend to have a look at the additional reading tips and try out online material listed in Section 9. You can run the workflows by simply copy-pasting the examples. For further, advanced material, you can test and modify further examples from the online book, and apply these techniques to your own data. Online support on installation and other matters, join us at Gitter 3.3 Installing and loading the required R packages You may need the examples from this subsection if you are installing the environment on your own computer. If you need to add new packages, you can modify the examples below. This section shows how to install and load all required packages into the R session, if needed. Only uninstalled packages are installed. Download the file pkgs.csv. This contains the list of packages that we recommend to preinstall. This can be done with the following code. # List of packages that we need pkg &lt;- read.csv(&quot;pkgs.csv&quot;)[,1] # List packages that are already installed pkg_already_installed &lt;- pkg[ pkg %in% installed.packages() ] # List remaining packages that need to be installed packages_to_install &lt;- setdiff(pkg, pkg_already_installed) # If there are packages that need to be installed, install them if( length(packages_to_install) ) { BiocManager::install(packages_to_install) } Now all required packages are installed, so let’s load them into the session. Some function names occur in multiple packages. That is why miaverse’s packages mia and miaViz are prioritized. Packages that are loaded first have higher priority. # Loading all packages into session. Returns true if package was successfully loaded. loaded &lt;- sapply(pkg, require, character.only = TRUE) as.data.frame(loaded) "],["reproducible-reporting-with-rmarkdown.html", "4 Reproducible reporting with Rmarkdown", " 4 Reproducible reporting with Rmarkdown Reproducible reporting is the starting point for robust interactive data science. Perform the following tasks: If you are entirely new to Markdown, take this 10 minute tutorial to get introduced to the most important functions within Markdown. Then experiment with different options with Rmarkdown Create a Rmarkdown template in RStudio, and render it into a document (markdown, PDF, docx or other format). In case you are new to Rmarkdown Rstudio provides resources to learn about the use cases and the basics of Rmarkdown. Further examples are tips for Rmarkdown are available in the online tutorial to reproducible reporting by Dr. C Titus Brown. "],["importing-microbiome-data.html", "5 Importing microbiome data 5.1 Data access 5.2 Importing microbiome data in R 5.3 Importing data: example solutions", " 5 Importing microbiome data This section demonstrates how to import microbiome profiling data in R. 5.1 Data access Option 1 ADHD-associated changes in gut microbiota and brain in a mouse model Tengeler AC et al. (2020) Gut microbiota from persons with attention-deficit/hyperactivity disorder affects the brain in mice. Microbiome 8:44. In this study, mice are colonized with microbiota from participants with ADHD (attention deficit hyperactivity disorder) and healthy participants. The aim of the study was to assess whether the mice display ADHD behaviors after being inoculated with ADHD microbiota, suggesting a role of the microbiome in ADHD pathology. Download the data from data subfolder. Option 2 Open data set of your own choice, different options are listed in OMA. 5.2 Importing microbiome data in R Import example data by modifying the examples in the online book section on data exploration and manipulation. The data files in our example are in biom format, which is a standard file format for microbiome data. Other file formats exist as well, and import details vary by platform. Here, we import biom data files into a specific data container (structure) in R, TreeSummarizedExperiment (TSE) Huang et al. (2020). This provides the basis for downstream data analysis in the miaverse data science framework. In this course, we focus on downstream analysis of taxonomic profiling data, and assume that the data has already been appropriately preprocessed and available in the TSE format. In addition to our example data, further demonstration data sets are readily available in the TSE format through microbiomeDataSets. Figure sources: Original article - Huang R et al. (2021) TreeSummarizedExperiment: a S4 class for data with hierarchical structure. F1000Research 9:1246. Reference Sequence slot extension - Lahti L et al. (2020) Upgrading the R/Bioconductor ecosystem for microbiome research F1000Research 9:1464 (slides). 5.3 Importing data: example solutions # Defining file paths biom_file_path &lt;- &quot;data/Tengeler2020/Aggregated_humanization2.biom&quot; sample_meta_file_path &lt;- &quot;data/Tengeler2020/Mapping_file_ADHD_aggregated.csv&quot; tree_file_path &lt;- &quot;data/Tengeler2020/Data_humanization_phylo_aggregation.tre&quot; library(mia) # Imports the data se &lt;- loadFromBiom(biom_file_path) names(rowData(se)) &lt;- c(&quot;Kingdom&quot;, &quot;Phylum&quot;, &quot;Class&quot;, &quot;Order&quot;, &quot;Family&quot;, &quot;Genus&quot;) # Goes through the whole DataFrame. Removes &#39;.*[kpcofg]__&#39; from strings, where [kpcofg] # is any character from listed ones, and .* any character. rowdata_modified &lt;- BiocParallel::bplapply(rowData(se), FUN = stringr::str_remove, pattern = &#39;.*[kpcofg]__&#39;) # Genus level has additional &#39;\\&quot;&#39;, so let&#39;s delete that also rowdata_modified &lt;- BiocParallel::bplapply(rowdata_modified, FUN = stringr::str_remove, pattern = &#39;\\&quot;&#39;) # rowdata_modified is a list, so it is converted back to DataFrame format. rowdata_modified &lt;- DataFrame(rowdata_modified) # And then assigned back to the SE object rowData(se) &lt;- rowdata_modified # We use this to check what type of data it is # read.table(sample_meta_file_path) # It seems like a comma separated file and it does not include headers # Let us read it and then convert from data.frame to DataFrame # (required for our purposes) sample_meta &lt;- DataFrame(read.table(sample_meta_file_path, sep = &quot;,&quot;, header = FALSE)) # Add sample names to rownames rownames(sample_meta) &lt;- sample_meta[,1] # Delete column that included sample names sample_meta[,1] &lt;- NULL # We can add headers colnames(sample_meta) &lt;- c(&quot;patient_status&quot;, &quot;cohort&quot;, &quot;patient_status_vs_cohort&quot;, &quot;sample_name&quot;) # Then it can be added to colData colData(se) &lt;- sample_meta # Convert to tse format tse &lt;- as(se, &quot;TreeSummarizedExperiment&quot;) # Reads the tree file tree &lt;- ape::read.tree(tree_file_path) # Add tree to rowTree rowTree(tse) &lt;- tree 5.3.1 Loading the processed data Alternatively, you can just load the already processed data set. tse &lt;- readRDS(&quot;data/Tengeler2020/tse.rds&quot;) ## Loading required package: SummarizedExperiment ## Loading required package: MatrixGenerics ## Loading required package: matrixStats ## ## Attaching package: &#39;MatrixGenerics&#39; ## The following objects are masked from &#39;package:matrixStats&#39;: ## ## colAlls, colAnyNAs, colAnys, colAvgsPerRowSet, colCollapse, ## colCounts, colCummaxs, colCummins, colCumprods, colCumsums, ## colDiffs, colIQRDiffs, colIQRs, colLogSumExps, colMadDiffs, ## colMads, colMaxs, colMeans2, colMedians, colMins, colOrderStats, ## colProds, colQuantiles, colRanges, colRanks, colSdDiffs, colSds, ## colSums2, colTabulates, colVarDiffs, colVars, colWeightedMads, ## colWeightedMeans, colWeightedMedians, colWeightedSds, ## colWeightedVars, rowAlls, rowAnyNAs, rowAnys, rowAvgsPerColSet, ## rowCollapse, rowCounts, rowCummaxs, rowCummins, rowCumprods, ## rowCumsums, rowDiffs, rowIQRDiffs, rowIQRs, rowLogSumExps, ## rowMadDiffs, rowMads, rowMaxs, rowMeans2, rowMedians, rowMins, ## rowOrderStats, rowProds, rowQuantiles, rowRanges, rowRanks, ## rowSdDiffs, rowSds, rowSums2, rowTabulates, rowVarDiffs, rowVars, ## rowWeightedMads, rowWeightedMeans, rowWeightedMedians, ## rowWeightedSds, rowWeightedVars ## Loading required package: GenomicRanges ## Loading required package: stats4 ## Loading required package: BiocGenerics ## ## Attaching package: &#39;BiocGenerics&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## IQR, mad, sd, var, xtabs ## The following objects are masked from &#39;package:base&#39;: ## ## anyDuplicated, append, as.data.frame, basename, cbind, colnames, ## dirname, do.call, duplicated, eval, evalq, Filter, Find, get, grep, ## grepl, intersect, is.unsorted, lapply, Map, mapply, match, mget, ## order, paste, pmax, pmax.int, pmin, pmin.int, Position, rank, ## rbind, Reduce, rownames, sapply, setdiff, sort, table, tapply, ## union, unique, unsplit, which.max, which.min ## Loading required package: S4Vectors ## ## Attaching package: &#39;S4Vectors&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## expand.grid, I, unname ## Loading required package: IRanges ## Loading required package: GenomeInfoDb ## Loading required package: Biobase ## Welcome to Bioconductor ## ## Vignettes contain introductory material; view with ## &#39;browseVignettes()&#39;. To cite Bioconductor, see ## &#39;citation(&quot;Biobase&quot;)&#39;, and for packages &#39;citation(&quot;pkgname&quot;)&#39;. ## ## Attaching package: &#39;Biobase&#39; ## The following object is masked from &#39;package:MatrixGenerics&#39;: ## ## rowMedians ## The following objects are masked from &#39;package:matrixStats&#39;: ## ## anyMissing, rowMedians ## Loading required package: SingleCellExperiment ## Loading required package: TreeSummarizedExperiment ## Loading required package: Biostrings ## Loading required package: XVector ## ## Attaching package: &#39;Biostrings&#39; ## The following object is masked from &#39;package:base&#39;: ## ## strsplit ## Loading required package: MultiAssayExperiment ## Loading required package: ggplot2 ## Loading required package: ggraph ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:Biostrings&#39;: ## ## collapse, intersect, setdiff, setequal, union ## The following object is masked from &#39;package:XVector&#39;: ## ## slice ## The following object is masked from &#39;package:Biobase&#39;: ## ## combine ## The following objects are masked from &#39;package:GenomicRanges&#39;: ## ## intersect, setdiff, union ## The following object is masked from &#39;package:GenomeInfoDb&#39;: ## ## intersect ## The following objects are masked from &#39;package:IRanges&#39;: ## ## collapse, desc, intersect, setdiff, slice, union ## The following objects are masked from &#39;package:S4Vectors&#39;: ## ## first, intersect, rename, setdiff, setequal, union ## The following objects are masked from &#39;package:BiocGenerics&#39;: ## ## combine, intersect, setdiff, union ## The following object is masked from &#39;package:matrixStats&#39;: ## ## count ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union "],["microbiome-data-exploration.html", "6 Microbiome data exploration 6.1 Data structure 6.2 Visualization 6.3 Exercises (optional) 6.4 Exploring data: example solutions", " 6 Microbiome data exploration Now we have loaded the data set into R. Next, let us walk through some basic operations for data exploration to confirm that the data has all the necessary components. Chapters 4-6 in OMA provide many more examples on exploring and manipulating microbiome data. 6.1 Data structure Let us now investigate how taxonomic profiling data is organized in R. Dimensionality tells us how many taxa and samples the data contains. As we can see, there are 151 taxa and 27 samples. dim(tse) ## [1] 151 27 The rowData slot contains a taxonomic table. This includes taxonomic information for each of the 151 entries. With the head() command, we can print just the beginning of the table. The rowData seems to contain information from 6 different taxonomy classes. knitr::kable(head(rowData(tse))) %&gt;% kableExtra::kable_styling(&quot;striped&quot;, latex_options=&quot;scale_down&quot;) %&gt;% kableExtra::scroll_box(width = &quot;100%&quot;) Kingdom Phylum Class Order Family Genus 1726470 Bacteria Bacteroidetes Bacteroidia Bacteroidales Bacteroidaceae Bacteroides 1726471 Bacteria Bacteroidetes Bacteroidia Bacteroidales Bacteroidaceae Bacteroides 17264731 Bacteria Bacteroidetes Bacteroidia Bacteroidales Porphyromonadaceae Parabacteroides 17264726 Bacteria Bacteroidetes Bacteroidia Bacteroidales Bacteroidaceae Bacteroides 1726472 Bacteria Verrucomicrobia Verrucomicrobiae Verrucomicrobiales Verrucomicrobiaceae Akkermansia 17264724 Bacteria Bacteroidetes Bacteroidia Bacteroidales Bacteroidaceae Bacteroides The colData slot contains sample metadata. It contains information for all 27 samples. However, here only the 6 first samples are shown as we use the head() command. There are 4 columns, that contain information, e.g., about patients’ status, and cohort. knitr::kable(head(colData(tse))) %&gt;% kableExtra::kable_styling(&quot;striped&quot;, latex_options=&quot;scale_down&quot;) %&gt;% kableExtra::scroll_box(width = &quot;100%&quot;) patient_status cohort patient_status_vs_cohort sample_name A110 ADHD Cohort_1 ADHD_Cohort_1 A110 A12 ADHD Cohort_1 ADHD_Cohort_1 A12 A15 ADHD Cohort_1 ADHD_Cohort_1 A15 A19 ADHD Cohort_1 ADHD_Cohort_1 A19 A21 ADHD Cohort_2 ADHD_Cohort_2 A21 A23 ADHD Cohort_2 ADHD_Cohort_2 A23 From here, we can draw summaries of the sample (column) data, for instance to see what is the patient status distribution. The command colData(tse)$patient_status fetches the data from the column, and table() creates a table that shows how many times each class is present, and sort() sorts the table to ascending order. There are 13 samples from patients having ADHD, and 14 control samples. sort(table(colData(tse)$patient_status)) ## ## ADHD Control ## 13 14 6.1.1 Transformations Microbial abundances are typically ‘compositional’ (relative) in the current microbiome profiling data sets. This is due to technical aspects of the data generation process (see e.g. Gloor et al., 2017). The next example calculates relative abundances as these are usually easier to interpret than plain counts. For some statistical models we need to transform the data into other formats as explained in above link (and as we will see later). # Calculates relative abundances, and stores the table to assays tse &lt;- transformCounts(tse, method = &quot;relabundance&quot;) A variety of standard transformations for microbiome data are available for TSE data objects through mia R package. 6.1.2 Aggregation Microbial species can be called at multiple taxonomic resolutions. We can easily agglomerate the data based on taxonomic ranks. Here, we agglomerate the data at Phylum level. tse_phylum &lt;- agglomerateByRank(tse, rank = &quot;Phylum&quot;) # Show dimensionality dim(tse_phylum) ## [1] 5 27 Now there are 5 taxa and 27 samples, meaning that there are 5 different Phylum level taxonomic groups. Looking at the rowData after agglomeration shows all Firmicutes are combined together, and all lower rank information is lost. From the assay we can see that all abundances of taxa that belong to Firmicutes are summed up. knitr::kable(head(rowData(tse_phylum))) %&gt;% kableExtra::kable_styling(&quot;striped&quot;, latex_options=&quot;scale_down&quot;) %&gt;% kableExtra::scroll_box(width = &quot;100%&quot;) Kingdom Phylum Class Order Family Genus Bacteroidetes Bacteria Bacteroidetes NA NA NA NA Verrucomicrobia Bacteria Verrucomicrobia NA NA NA NA Proteobacteria Bacteria Proteobacteria NA NA NA NA Firmicutes Bacteria Firmicutes NA NA NA NA Cyanobacteria Bacteria Cyanobacteria NA NA NA NA If you are sharp, you have by now noticed that all the aggregated values in the above example are NA’s (missing data). This is because the agglomeration is missing abundances for certain taxa, and in that case the sum is not defined by default (na.rm = FALSE). We can ignore the missing values in summing up the data by setting na.rm = TRUE; then the taxa that do not have information in specified level will be removed. Those taxa that do not have information in specified level are agglomerated at lowest possible level that is left after agglomeration. temp &lt;- rowData(agglomerateByRank(tse, rank = &quot;Genus&quot;)) # Prints those taxa that do not have information at the Genus level knitr::kable(head(temp[temp$Genus == &quot;&quot;,])) %&gt;% kableExtra::kable_styling(&quot;striped&quot;, latex_options=&quot;scale_down&quot;) %&gt;% kableExtra::scroll_box(width = &quot;100%&quot;) Kingdom Phylum Class Order Family Genus Family:Lachnospiraceae Bacteria Firmicutes Clostridia Clostridiales Lachnospiraceae Order:Bacteroidales Bacteria Bacteroidetes Bacteroidia Bacteroidales Order:Clostridiales Bacteria Firmicutes Clostridia Clostridiales Family:Enterobacteriaceae Bacteria Proteobacteria Gammaproteobacteria Enterobacteriales Enterobacteriaceae Order:Gastranaerophilales Bacteria Cyanobacteria Melainabacteria Gastranaerophilales Here agglomeration is done similarly, but na.rm = TRUE temp2 &lt;- rowData(agglomerateByRank(tse, rank = &quot;Genus&quot;, na.rm = TRUE)) print(paste0(&quot;Agglomeration with na.rm = FALSE: &quot;, dim(temp)[1], &quot; taxa.&quot;)) ## [1] &quot;Agglomeration with na.rm = FALSE: 54 taxa.&quot; print(paste0(&quot;Agglomeration with na.rm = TRUE: &quot;, dim(temp2)[1], &quot; taxa.&quot;)) ## [1] &quot;Agglomeration with na.rm = TRUE: 49 taxa.&quot; The mia package contains further examples on various data agglomeration and splitting options. 6.2 Visualization The miaViz package facilitates data visualization. Let us plot the Phylum level abundances. # Here we specify &quot;relabundance&quot; to be abundance table that we use for plotting. # Note that we can use agglomerated or non-agglomerated tse as an input, because # the function agglomeration is built-in option. # Legend does not fit into picture, so its height is reduced. plot_abundance &lt;- plotAbundance(tse, abund_values=&quot;relabundance&quot;, rank = &quot;Phylum&quot;) + theme(legend.key.height = unit(0.5, &quot;cm&quot;)) + scale_y_continuous(label = scales::percent) ## Scale for &#39;y&#39; is already present. Adding another scale for &#39;y&#39;, which will ## replace the existing scale. plot_abundance Density plot shows the overall abundance distribution for a given taxonomic group. Let us check the relative abundance of Firmicutes across the sample collection. The density plot is a smoothened version of a standard histogram. The plot shows peak abundances around 30 %. # Subset data by taking only Firmicutes tse_firmicutes &lt;- tse_phylum[&quot;Firmicutes&quot;] # Gets the abundance table abundance_firmicutes &lt;- assay(tse_firmicutes, &quot;relabundance&quot;) # Creates a data frame object, where first column includes abundances firmicutes_abund_df &lt;- as.data.frame(t(abundance_firmicutes)) # Rename the first and only column colnames(firmicutes_abund_df) &lt;- &quot;abund&quot; # Creates a plot. Parameters inside feom_density are optional. With # geom_density(bw=1000), it is possible to adjust bandwidth. firmicutes_abund_plot &lt;- ggplot(firmicutes_abund_df, aes(x = abund)) + geom_density(color=&quot;darkred&quot;, fill=&quot;lightblue&quot;) + labs(x = &quot;Relative abundance&quot;, title = &quot;Firmicutes&quot;) + theme_classic() + # Changes the background scale_x_continuous(label = scales::percent) firmicutes_abund_plot For more visualization options and examples, see the miaViz vignette. 6.3 Exercises (optional) Explore some of the following questions on your own by following online examples. Prepare a reproducible report (Rmarkdown), and include the code that you use to import the data and generate the analyses. Abundance table Retrieve the taxonomic abundance table from the example data set (TSE object). Tip: check “assays” in data import section How many different samples and genus-level groups this phyloseq object has? Tips: see dim(), rowData() What is the maximum abundance of Akkermansia in this data set? Tip: aggregate the data to Genus level with agglomerateByRank, pick abundance assay, and check a given genus (row) in the assay Draw a histogram of library sizes (total number of reads per sample). Tip: Library size section in OMA. You can use the available function, or count the sum of reads per sample by using the colSums command applied on the abundance table. Check Vandeputte et al. 2017 for further discussion on the differences between absolute and relative quantification of microbial abundances. Taxonomy table Retrieve the taxonomy table and print out the first few lines of it with the R command head(). Investigate how many different phylum-level groups this phyloseq object has? Tips: rowData, taxonomicRanks in OMA. Sample metadata Retrieve sample metadata. How many patient groups this data set has? Draw a histogram of sample diversities. Tips: colData Subsetting Pick a subset of the data object including only ADHD individuals from Cohort 1. How many there are? Tips: subsetting in OMA Transformations The data contains read counts. We can convert these into relative abundances and other formats. Compare abundance of a given taxonomic group using the example data before and after the compositionality transformation (with a cross-plot, for instance). You can also compare the results to CLR-transformed data (see e.g. Gloor et al. 2017) Visual exploration Visualize the population distribution of abundances for certain taxonomic groups. Do the same for CLR-transformed abundances. Tip: assays, transformCounts Experiment with other data manipulation tools from OMA. 6.4 Exploring data: example solutions Abundance table Retrieve the taxonomic abundance table from the example data set (TSE object). # We show only part of it assays(tse)$counts[1:6,1:6] ## A110 A12 A15 A19 A21 A23 ## 1726470 17722 11630 0 8806 1740 1791 ## 1726471 12052 0 2679 2776 540 229 ## 17264731 0 970 0 549 145 0 ## 17264726 0 1911 0 5497 659 0 ## 1726472 1143 1891 1212 584 84 700 ## 17264724 0 6498 0 4455 610 0 How many different samples and genus-level groups this phyloseq object has? dim(rowData(tse)) ## [1] 151 6 What is the maximum abundance of Akkermansia in this data set? # Agglomerating to Genus level tse_genus &lt;- agglomerateByRank(tse,rank=&quot;Genus&quot;) # Retrieving the count for Akkermansia Akkermansia_abund &lt;- assays(tse_genus)$count[&quot;Genus:Akkermansia&quot;,] max(Akkermansia_abund) ## [1] 2535 Draw a histogram of library sizes (total number of reads per sample). library(scater) ## Loading required package: scuttle tse &lt;- addPerCellQC(tse) # adding a new column &quot;sum&quot; to colData, of total counts/sample. hist(colData(tse)$sum, xlab = &quot;Total number of reads per sample&quot;, main = &quot;Histogram of library sizes&quot;) * Taxonomy table Retrieve the taxonomy table and print out the first few lines of it with the R command head(). Investigate how many different phylum-level groups this phyloseq object has? head(rowData(tse)) ## DataFrame with 6 rows and 6 columns ## Kingdom Phylum Class Order ## &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; ## 1726470 Bacteria Bacteroidetes Bacteroidia Bacteroidales ## 1726471 Bacteria Bacteroidetes Bacteroidia Bacteroidales ## 17264731 Bacteria Bacteroidetes Bacteroidia Bacteroidales ## 17264726 Bacteria Bacteroidetes Bacteroidia Bacteroidales ## 1726472 Bacteria Verrucomicrobia Verrucomicrobiae Verrucomicrobiales ## 17264724 Bacteria Bacteroidetes Bacteroidia Bacteroidales ## Family Genus ## &lt;character&gt; &lt;character&gt; ## 1726470 Bacteroidaceae Bacteroides ## 1726471 Bacteroidaceae Bacteroides ## 17264731 Porphyromonadaceae Parabacteroides ## 17264726 Bacteroidaceae Bacteroides ## 1726472 Verrucomicrobiaceae Akkermansia ## 17264724 Bacteroidaceae Bacteroides taxonomyRanks(tse) # The taxonomic ranks available ## [1] &quot;Kingdom&quot; &quot;Phylum&quot; &quot;Class&quot; &quot;Order&quot; &quot;Family&quot; &quot;Genus&quot; unique(rowData(tse)[&quot;Phylum&quot;]) # phylum-level groups ## DataFrame with 5 rows and 1 column ## Phylum ## &lt;character&gt; ## 1726470 Bacteroidetes ## 1726472 Verrucomicrobia ## 17264729 Proteobacteria ## 172647189 Firmicutes ## 17264742 Cyanobacteria length(unique(rowData(tse)[&quot;Phylum&quot;])[,1]) # number of phylum-level groups ## [1] 5 Sample metadata Retrieve sample metadata. How many patient groups this data set has? Draw a histogram of sample diversities. colData(tse) # samples metadata ## DataFrame with 27 rows and 7 columns ## patient_status cohort patient_status_vs_cohort sample_name sum ## &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;numeric&gt; ## A110 ADHD Cohort_1 ADHD_Cohort_1 A110 37394 ## A12 ADHD Cohort_1 ADHD_Cohort_1 A12 40584 ## A15 ADHD Cohort_1 ADHD_Cohort_1 A15 16077 ## A19 ADHD Cohort_1 ADHD_Cohort_1 A19 39210 ## A21 ADHD Cohort_2 ADHD_Cohort_2 A21 6351 ## ... ... ... ... ... ... ## A26 Control Cohort_2 Control_Cohort_2 A26 20431 ## A27 Control Cohort_2 Control_Cohort_2 A27 14636 ## A33 Control Cohort_3 Control_Cohort_3 A33 13051 ## A35 Control Cohort_3 Control_Cohort_3 A35 12642 ## A38 Control Cohort_3 Control_Cohort_3 A38 15544 ## detected total ## &lt;numeric&gt; &lt;numeric&gt; ## A110 68 37394 ## A12 51 40584 ## A15 68 16077 ## A19 62 39210 ## A21 58 6351 ## ... ... ... ## A26 64 20431 ## A27 86 14636 ## A33 78 13051 ## A35 62 12642 ## A38 74 15544 unique(colData(tse)$patient_status) # patient groups ## [1] &quot;ADHD&quot; &quot;Control&quot; # Example of sample diversity using Shannon index tse &lt;- mia::estimateDiversity(tse, abund_values = &quot;counts&quot;, index = &quot;shannon&quot;, name = &quot;shannon&quot;) hist(colData(tse)$shannon, xlab = &quot;Shannon index&quot;, main = &quot;Histogram of sample diversity&quot;) Subsetting Pick a subset of the data object including only ADHD individuals from Cohort 1. How many there are? sub_cohort_1 &lt;- tse[, colData(tse)$cohort==&quot;Cohort_1&quot;] sub_cohort_1_ADHD &lt;- sub_cohort_1[, colData(sub_cohort_1)$patient_status==&quot;ADHD&quot;] colData(sub_cohort_1_ADHD) ## DataFrame with 4 rows and 8 columns ## patient_status cohort patient_status_vs_cohort sample_name sum ## &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;numeric&gt; ## A110 ADHD Cohort_1 ADHD_Cohort_1 A110 37394 ## A12 ADHD Cohort_1 ADHD_Cohort_1 A12 40584 ## A15 ADHD Cohort_1 ADHD_Cohort_1 A15 16077 ## A19 ADHD Cohort_1 ADHD_Cohort_1 A19 39210 ## detected total shannon ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## A110 68 37394 1.76541 ## A12 51 40584 2.71644 ## A15 68 16077 3.17810 ## A19 62 39210 2.89199 Transformations The data contains read counts. We can convert these into relative abundances and other formats. Compare abundance of a given taxonomic group using the example data before and after the compositionality transformation (with a cross-plot, for instance). You can also compare the results to CLR-transformed data (see e.g. Gloor et al. 2017) tse &lt;- transformCounts(tse, method = &quot;relabundance&quot;) tse &lt;- transformCounts(tse, method = &quot;clr&quot;, abund_values = &quot;counts&quot;,pseudocount = 1) ## Warning: All the total abundances of samples do not sum-up to a fixed constant. ## Please consider to apply, e.g., relative transformation in prior to CLR ## transformation. # Lets compare with taxa: A29 taxa &lt;- &quot;A29&quot; df &lt;- as.data.frame(list( counts=assays(tse)$counts[,taxa], relabundance=assays(tse)$relabundance[,taxa], clr=assays(tse)$clr[,taxa]) ) ggplot(df, aes(x=counts,y=relabundance))+ geom_point()+ geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ggplot(df, aes(x=counts,y=clr))+ geom_point()+ geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ggplot(df, aes(x=relabundance,y=clr))+ geom_point()+ geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; * Visual exploration Visualize the population distribution of abundances for certain taxonomic groups. Do the same for CLR-transformed abundances. # Same taxa used as earlier ggplot(df, aes(x=counts,colour=&quot;blue&quot;)) + geom_density(alpha=.2)+ theme(legend.position = &quot;none&quot;)+ labs(title =paste(&quot;Distribution of counts for&quot;,taxa, collapse = &quot;: &quot;)) ggplot(df, aes(x=clr,colour=&quot;red&quot;)) + geom_density(alpha=.2)+ theme(legend.position = &quot;none&quot;)+ labs(title =paste(&quot;Distribution of clr for&quot;,taxa, collapse = &quot;: &quot;)) "],["alpha-diversity-demo.html", "7 Alpha diversity demo 7.1 Alpha diversity estimation 7.2 Visualizing alpha diversity 7.3 Comparing alpha diversity 7.4 Exercises", " 7 Alpha diversity demo 7.1 Alpha diversity estimation First let`s load the required packages and data set library(mia) library(miaViz) library(tidyverse) # library(vegan) tse &lt;- read_rds(&quot;data/Tengeler2020/tse.rds&quot;) tse ## class: TreeSummarizedExperiment ## dim: 151 27 ## metadata(0): ## assays(1): counts ## rownames(151): 1726470 1726471 ... 17264756 17264757 ## rowData names(6): Kingdom Phylum ... Family Genus ## colnames(27): A110 A12 ... A35 A38 ## colData names(4): patient_status cohort patient_status_vs_cohort ## sample_name ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## rowLinks: a LinkDataFrame (151 rows) ## rowTree: 1 phylo tree(s) (151 leaves) ## colLinks: NULL ## colTree: NULL Then let’s estimate multiple diversity indices. ?estimateDiversity tse &lt;- estimateDiversity(tse, index = c(&quot;shannon&quot;,&quot;gini_simpson&quot;,&quot;faith&quot;), name = c(&quot;shannon&quot;,&quot;gini_simpson&quot;,&quot;faith&quot;)) head(colData(tse)) ## DataFrame with 6 rows and 7 columns ## patient_status cohort patient_status_vs_cohort sample_name shannon ## &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;numeric&gt; ## A110 ADHD Cohort_1 ADHD_Cohort_1 A110 1.76541 ## A12 ADHD Cohort_1 ADHD_Cohort_1 A12 2.71644 ## A15 ADHD Cohort_1 ADHD_Cohort_1 A15 3.17810 ## A19 ADHD Cohort_1 ADHD_Cohort_1 A19 2.89199 ## A21 ADHD Cohort_2 ADHD_Cohort_2 A21 2.84198 ## A23 ADHD Cohort_2 ADHD_Cohort_2 A23 2.79794 ## gini_simpson faith ## &lt;numeric&gt; &lt;numeric&gt; ## A110 0.669537 7.39224 ## A12 0.871176 6.29378 ## A15 0.930561 6.60608 ## A19 0.899210 6.79708 ## A21 0.885042 6.65110 ## A23 0.859813 5.96246 We can see that the variables are included in the data. Similarly, let’s calculate richness indices. tse &lt;- estimateRichness(tse, index = c(&quot;chao1&quot;,&quot;observed&quot;)) head(colData(tse)) ## DataFrame with 6 rows and 10 columns ## patient_status cohort patient_status_vs_cohort sample_name shannon ## &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;character&gt; &lt;numeric&gt; ## A110 ADHD Cohort_1 ADHD_Cohort_1 A110 1.76541 ## A12 ADHD Cohort_1 ADHD_Cohort_1 A12 2.71644 ## A15 ADHD Cohort_1 ADHD_Cohort_1 A15 3.17810 ## A19 ADHD Cohort_1 ADHD_Cohort_1 A19 2.89199 ## A21 ADHD Cohort_2 ADHD_Cohort_2 A21 2.84198 ## A23 ADHD Cohort_2 ADHD_Cohort_2 A23 2.79794 ## gini_simpson faith chao1 chao1_se observed ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## A110 0.669537 7.39224 68 0.000000 68 ## A12 0.871176 6.29378 51 0.000000 51 ## A15 0.930561 6.60608 68 0.000000 68 ## A19 0.899210 6.79708 62 0.000000 62 ## A21 0.885042 6.65110 58 0.000000 58 ## A23 0.859813 5.96246 61 0.247942 61 7.2 Visualizing alpha diversity We can plot the distributions of individual indices: #individual plot p &lt;- as_tibble(colData(tse)) %&gt;% ggplot(aes(shannon)) + geom_histogram() print(p) #multiple plots p &lt;- as_tibble(colData(tse)) %&gt;% pivot_longer(cols = c(&quot;shannon&quot;,&quot;gini_simpson&quot;,&quot;faith&quot;,&quot;chao1&quot;,&quot;observed&quot;), names_to = &quot;index&quot;, values_to = &quot;alpha&quot;) %&gt;% ggplot(aes(alpha)) + geom_histogram() + facet_wrap(vars(index), scales = &quot;free&quot;) print(p) and the correlation between indices: p &lt;- as_tibble(colData(tse)) %&gt;% pivot_longer(cols = c(&quot;shannon&quot;,&quot;gini_simpson&quot;,&quot;faith&quot;,&quot;chao1&quot;,&quot;observed&quot;), names_to = &quot;index&quot;, values_to = &quot;alpha&quot;) %&gt;% full_join(.,., by = &quot;sample_name&quot;) %&gt;% ggplot( aes(x = alpha.x, y = alpha.y)) + geom_point() + geom_smooth() + facet_wrap(index.x ~ index.y, scales = &quot;free&quot;) print(p) 7.3 Comparing alpha diversity It is often interesting to look for any group differences: p &lt;- as_tibble(colData(tse)) %&gt;% pivot_longer(cols = c(&quot;shannon&quot;,&quot;gini_simpson&quot;,&quot;faith&quot;,&quot;chao1&quot;,&quot;observed&quot;), names_to = &quot;index&quot;, values_to = &quot;alpha&quot;) %&gt;% ggplot( aes(x = patient_status, y = alpha)) + geom_boxplot(outlier.shape = NA) + geom_jitter(alpha =0.5) + facet_wrap(vars(index), scales = &quot;free&quot;) print(p) Moreover, we can test the group differences by parametric or non-parametric tests: df1 &lt;- as_tibble(colData(tse)) %&gt;% pivot_longer(cols = c(&quot;faith&quot;,&quot;chao1&quot;,&quot;observed&quot;), names_to = &quot;index&quot;, values_to = &quot;alpha&quot;) %&gt;% group_by(index) %&gt;% nest() %&gt;% mutate(test_pval = map_dbl(data, ~ t.test(alpha ~ patient_status, data = .x)$p.value)) %&gt;% mutate(test = &quot;ttest&quot; ) df2 &lt;- as_tibble(colData(tse)) %&gt;% pivot_longer(cols = c(&quot;shannon&quot;,&quot;gini_simpson&quot;), names_to = &quot;index&quot;, values_to = &quot;alpha&quot;) %&gt;% group_by(index) %&gt;% nest() %&gt;% mutate(test_pval = map_dbl(data, ~ wilcox.test(alpha ~ patient_status, data = .x)$p.value))%&gt;% mutate(test = &quot;wilcoxon&quot; ) df &lt;- rbind(df1,df2) %&gt;% select(-data) %&gt;% arrange(test_pval) %&gt;% ungroup() df ## # A tibble: 5 × 3 ## index test_pval test ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 shannon 0.488 wilcoxon ## 2 gini_simpson 0.685 wilcoxon ## 3 chao1 0.856 ttest ## 4 observed 0.900 ttest ## 5 faith 0.983 ttest End of the demo. 7.4 Exercises Do “Alpha diversity basics” from the exercises. "],["beta-diversity-demo.html", "8 Beta diversity demo 8.1 Visualizations 8.2 Hypothesis testing 8.3 Exercises", " 8 Beta diversity demo 8.1 Visualizations Lets generate ordination plots with different methods and transformations. #### calculating Bray Curtis dissimilarity and PCoA tse &lt;- transformSamples(tse, method = &quot;relabundance&quot;) tse &lt;- runMDS(tse, FUN = vegan::vegdist, method = &quot;bray&quot;, name = &quot;PCoA_BC&quot;, exprs_values = &quot;relabundance&quot;) p &lt;- plotReducedDim(tse, &quot;PCoA_BC&quot;, colour_by = &quot;patient_status&quot;) # Add explained variance for each axis e &lt;- attr(reducedDim(tse, &quot;PCoA_BC&quot;), &quot;eig&quot;); rel_eig &lt;- e/sum(e[e&gt;0]) p &lt;- p + labs(x = paste(&quot;PCoA 1 (&quot;, round(100 * rel_eig[[1]],1), &quot;%&quot;, &quot;)&quot;, sep = &quot;&quot;), y = paste(&quot;PCoA 2 (&quot;, round(100 * rel_eig[[2]],1), &quot;%&quot;, &quot;)&quot;, sep = &quot;&quot;)) print(p) #### Aitchinson distances and PCA tse &lt;- transformSamples(tse, method = &quot;clr&quot;, pseudocount = 1) ## Warning: All the total abundances of samples do not sum-up to a fixed constant. ## Please consider to apply, e.g., relative transformation in prior to CLR ## transformation. tse &lt;- runMDS(tse, FUN = vegan::vegdist, name = &quot;MDS_euclidean&quot;, method = &quot;euclidean&quot;, exprs_values = &quot;clr&quot;) p &lt;- plotReducedDim(tse, &quot;MDS_euclidean&quot;, colour_by = &quot;patient_status_vs_cohort&quot;) # Add explained variance for each axis e &lt;- attr(reducedDim(tse, &quot;MDS_euclidean&quot;), &quot;eig&quot;); rel_eig &lt;- e/sum(e[e&gt;0]) p &lt;- p + labs(x = paste(&quot;Axis 1 (&quot;, round(100 * rel_eig[[1]],1), &quot;%&quot;, &quot;)&quot;, sep = &quot;&quot;), y = paste(&quot;Axis 2 (&quot;, round(100 * rel_eig[[2]],1), &quot;%&quot;, &quot;)&quot;, sep = &quot;&quot;)) print(p) PCA is a subtype of MDS with Euclidean distances, below is a different alternative for running the same analysis. # alternative method tse &lt;- runPCA(tse, name = &quot;PCA&quot;, exprs_values = &quot;clr&quot;, ncomponents = 10) plotReducedDim(tse, &quot;PCA&quot;, colour_by = &quot;patient_status_vs_cohort&quot;) One can use also ggplot for ordination plots for the flexible adaptablity. dis &lt;- vegan::vegdist(t(assays(tse)$counts), method = &quot;jaccard&quot;) # principal coordinate analysis jaccard_pcoa &lt;- ecodist::pco(dis) # a data frame from principal coordinates and groupng variable jaccard_pcoa_df &lt;- data.frame(pcoa1 = jaccard_pcoa$vectors[,1], pcoa2 = jaccard_pcoa$vectors[,2], patient_status_vs_cohort = colData(tse)$patient_status_vs_cohort) # plot jaccard_plot &lt;- ggplot(data = jaccard_pcoa_df, aes(x=pcoa1, y=pcoa2, color = patient_status_vs_cohort)) + geom_point() + labs(x = paste(&quot;Axis 1 (&quot;, round(100 * jaccard_pcoa$values[[1]] / sum(jaccard_pcoa$values), 1), &quot;%&quot;, &quot;)&quot;, sep = &quot;&quot;), y = paste(&quot;Axis 2 (&quot;, round(100 * jaccard_pcoa$values[[2]] / sum(jaccard_pcoa$values), 1), &quot;%&quot;, &quot;)&quot;, sep = &quot;&quot;), title = &quot;Jaccard PCoA&quot;) + theme(title = element_text(size = 12)) + theme_light() jaccard_plot 8.2 Hypothesis testing PERMANOVA with the function adonis is most commonly used to detect differences in multivariate data. adonis function was recently updated with slightly different functionality. Now the adonis2 allows independent analysis of terms. variable_names &lt;- c(&quot;patient_status&quot;, &quot;cohort&quot;) tse_genus &lt;- agglomerateByRank(tse, &quot;Genus&quot;) ## Warning: &#39;clr&#39; includes negative values. ## Agglomeration of it might lead to meaningless values. ## Check the assay, and consider doing transformation again manually with agglomerated data. # Apply relative transform tse_genus &lt;- transformSamples(tse_genus, method = &quot;relabundance&quot;) set.seed(12346) # We choose 99 random permutations for speed. Consider applying more (999 or 9999) assay &lt;- t(assay(tse_genus,&quot;relabundance&quot;)) mod &lt;- paste(&quot;assay ~&quot;, paste(variable_names, collapse=&quot;+&quot;)) %&gt;% as.formula() permanova2 &lt;- vegan::adonis2(mod, by = &quot;margin&quot;, # each term analyzed individually data = colData(tse), method = &quot;bray&quot;, permutations = 99) print(permanova2) ## Permutation test for adonis under reduced model ## Marginal effects of terms ## Permutation: free ## Number of permutations: 99 ## ## vegan::adonis2(formula = mod, data = colData(tse), permutations = 99, method = &quot;bray&quot;, by = &quot;margin&quot;) ## Df SumOfSqs R2 F Pr(&gt;F) ## patient_status 1 0.1885 0.05817 1.490 0.23 ## cohort 2 0.1450 0.04474 0.573 0.75 ## Residual 23 2.9104 0.89787 ## Total 26 3.2414 1.00000 # older adonis for reference permanova &lt;- vegan::adonis(mod, #by = &quot;margin&quot;, # each term analyzed sequentially data = colData(tse), method = &quot;bray&quot;, permutations = 99) ## &#39;adonis&#39; will be deprecated: use &#39;adonis2&#39; instead permanova$aov.tab ## Permutation: free ## Number of permutations: 99 ## ## Terms added sequentially (first to last) ## ## Df SumsOfSqs MeanSqs F.Model R2 Pr(&gt;F) ## patient_status 1 0.1860 0.186024 1.47011 0.05739 0.22 ## cohort 2 0.1450 0.072503 0.57298 0.04474 0.79 ## Residuals 23 2.9104 0.126537 0.89787 ## Total 26 3.2414 1.00000 With older adonis version one cam calculate top coefficients driving the differences between groups. # older adonis supplies the coefficients coef &lt;- coefficients(permanova)[&quot;cohort1&quot;,] top.coef &lt;- sort(head(coef[rev(order(abs(coef)))],20)) # plot top_taxa_coeffient_plot &lt;- ggplot(data.frame(x = top.coef, y = factor(names(top.coef), unique(names(top.coef)))), aes(x = x, y = y)) + geom_bar(stat=&quot;identity&quot;) + labs(x=&quot;&quot;, y=&quot;&quot;, title=&quot;Top Taxa&quot;) + theme_bw() top_taxa_coeffient_plot 8.2.1 Testing the differences in dispersion PEMRANOVA doesn’t differentiate between different within-group variation, i.e. dispersion, or the mean differences between groups, i.e. the location of the centroid. Follow-up testing can be done with PERMDISP2 implemented in the vegan package. dis &lt;- vegan::vegdist(t(assays(tse)$counts), method = &quot;bray&quot;) b &lt;- vegan::betadisper(dis, colData(tse)$cohort) print(anova(b)) ## Analysis of Variance Table ## ## Response: Distances ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## Groups 2 0.000375 0.0001875 0.0166 0.9835 ## Residuals 24 0.270795 0.0112831 # boxplor for distances to centroid p &lt;- cbind(distance = as.numeric(b$distances), cohort = colData(tse)$cohort) %&gt;% as_tibble() %&gt;% mutate(distance = as.numeric(distance)) %&gt;% ggplot(aes(cohort, distance)) + geom_boxplot() + theme_light() print(p) End of the demo. 8.3 Exercises Do “Beta diversity” from the exercises. "],["material.html", "9 Study material 9.1 Online tutorial 9.2 Lecture slides 9.3 Tasks 9.4 Extra material on miaverse and R programming", " 9 Study material 9.1 Online tutorial The course will utilize material from the online book (beta version) Orchestrating Microbiome Analysis with R/Bioconductor (OMA). We encourage to familiarize with this material and test examples already before the course. 9.2 Lecture slides To be added. 9.3 Tasks Seek guidance from the https://microbiome.github.io/OMA/ Exercises Example solutions 9.4 Extra material on miaverse and R programming Further information on the data science framework "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
